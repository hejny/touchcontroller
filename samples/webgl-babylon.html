<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="UTF-8" />
        <title>Sample of TouchController in Babylon 3D+VR</title>
        <link rel="stylesheet" type="text/css" href="./assets/common.css" />

        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Babylon Template</title>
        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            /*
            #scene {
                border: none;
                width: 100%;
                height: 100%;
                 touch-action: none; 
            }*/
        </style>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="../dist/main.dev.browser.js"></script>
        <script src="/node_modules/xyzt/dist/main.browser.js"></script>
    </head>
    <body>
        <canvas id="scene1" class="scene" width="500" height="500"></canvas>
        <canvas id="scene2" class="scene" width="500" height="500"></canvas>
        <!-- touch-action="none" for best results from PEP -->
        <script>
            (async () => {
                const { TouchController /*, Plugins*/, TouchControllerDebugLayer } = window.TouchController;

                // TODO: Import from waitasecond same way as importing xyzt
                function forAnimationFrame() {
                    return new Promise((resolve) => {
                        requestAnimationFrame((now) => {
                            resolve(now);
                        });
                    });
                }

                const canvas1 = document.getElementById('scene1');
                const canvas2 = document.getElementById('scene2');

                canvas1.addEventListener('pointerdown', () => {
                    console.log('pointerdown');
                });

                canvas1.addEventListener('mousedown', () => {
                    console.log('mousedown');
                });

                const engine = new BABYLON.Engine(canvas2, true);

                // -------------- Scene
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(1, 1, 1);

                const camera1 = new BABYLON.UniversalCamera('camera1', BABYLON.Vector3.Zero(), scene);

                //vrHelper.deviceOrientationCamera.detachControl();
                //scene.activeCamera.setTarget(BABYLON.Vector3.Zero());

                // -------------- Lighting
                const light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
                light.intensity = 0.7;
                // -------------- 3D Objects
                (async () => {
                    const { meshes } = await BABYLON.SceneLoader.ImportMeshAsync(
                        null,
                        './assets/',
                        'avocado.glb',
                        scene,
                    );
                    console.log({ meshes });

                    const [_, mesh] = meshes;

                    console.log({ mesh });

                    for (let i = 0; i < 666; i++) {
                        const instance = mesh.createInstance();
                        instance.rotation = new BABYLON.Vector3(
                            Math.PI * 2 * Math.random(),
                            Math.PI * 2 * Math.random(),
                            Math.PI * 2 * Math.random(),
                        );
                        instance.position = new BABYLON.Vector3(
                            (Math.random() - 0.5) * 100,
                            (Math.random() - 0.5) * 100,
                            (Math.random() - 0.5) * 100,
                        );
                        const scaling = Math.random() * 100;
                        instance.scaling = new BABYLON.Vector3(scaling, scaling, scaling);

                        /*/
                        (async () => {
                            const rotationSpeed = new BABYLON.Vector3(
                                Math.PI * 0.01 * Math.random(),
                                Math.PI * 0.01 * Math.random(),
                                Math.PI * 0.01 * Math.random(),
                            );
                            while (true) {
                                await forAnimationFrame();
                                instance.rotation.addInPlace(rotationSpeed);
                            }
                        })();
                        /**/
                    }

                    /*for (const mesh of meshes) {
                        const meshInstance = mesh.createInstance();
                        meshInstance.rotation = new BABYLON.Vector3(Math.PI / 4, 0, 0);
                        meshInstance.scaling = new BABYLON.Vector3(3, 3, 3);
                    }*/
                    /*
                    // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
                    const ground = BABYLON.Mesh.CreateGround('ground1', 6, 6, 2, scene);

                    // Our built-in 'sphere' shape. Params: name, subdivs, size, scene
                    const sphere = BABYLON.Mesh.CreateSphere('sphere1', 16, 2, scene);

                    // Move the sphere upward 1/2 its height

                    // TODO change the position of the sphere so it floats above the plane
                    sphere.position.y = 0;
                */
                })();
                // -------------- Picking with TouchController

                canvas1.addEventListener('pointerdown', () => {
                    console.log('pointerdown');
                });

                canvas1.addEventListener('mousedown', () => {
                    console.log('mousedown');
                    // Miluju a tohle v tom kodu zustane ;)
                });

                const touchController = new TouchController({ element: canvas1 });
                // Plugins.toggleTouchByTap(touchController);

                touchController.touches.subscribe(async (touch) => {
                    const { x, y } = (await touch.firstFrame).position;
                    console.log({ touch, x, y });
                    const pickingInfo = scene.pick(x, y /*(mesh)=>{
                    return true;
                }*/);

                    console.log({ pickingInfo });

                    pickingInfo.pickedMesh.rotation.y += (Math.PI / 180) * 30;
                });

                new TouchControllerDebugLayer(touchController);

                // -------------- Render loop

                engine.runRenderLoop(() => {
                    scene.render();
                });
                // Watch for browser/canvas resize events
                window.addEventListener('resize', () => {
                    engine.resize();
                });
            })();
        </script>
    </body>
</html>
